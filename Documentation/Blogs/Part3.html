<!doctype HTML>

<html>
<body>
	<h2>Part 3: Login and Session models</h2>

	<h4>Necessary Materials:</h4>
	<ul>
		<li>Node.js</li>
		<li>Express</li>
	</ul>

	<h4>Node Modules Used:</h4>
	<ul>
		<li>Couchbase Node.js SDK/N1QL</li>
		<li>body-parser</li>
		<li>uuid</li>
	</ul>

	<p>So far, we have gotten through making the registration for Touchbase, and how to send email verifications. These are a core part of getting a user started on any social media website, but now we must make sure that they can login and access the content we guaranteed them. The API endpoint for this can be seen in <strong>&#39;/api/loginAuth&#39;</strong> which is pasted below. </p>

	<h4>'/api/loginAuth' API</h4>

	<script src="https://gist.github.com/pranavmayuram/c2d18da0dd6075152f69.js"></script>

	<p>The process starts with making sure that both the email and password are properly passed to the back-end. If they are missing, an error will be returned. In the current implementation of this, the error shows up on the front-end with an ng-messages error.</p>

	<p>After the first validation is completed, the <strong>&#39;User.advancedSearch&#39;</strong> function is executed to find the document for the email address that the user is searching for. The function should ideally return one result of the exact email address that the user has. As you can see, the first code snippet of the loginAuth API, <strong>&#39;if (x.length === 0)&#39;</strong>, checks to see if the email address has been registered, and if not, it throws an error. Secondly, it checks to make sure the username and password combination are valid, by calling the <strong>&#39;User.validatePassword&#39;</strong> function which makes sure that the hashed version of the password entered by the user matches the hashed version that was stored in the user&#39;s document. This uses the same hashing function we used in the original user document we created in the <strong>&#39;User.create&#39;</strong> function.</p>

	<h4>User.validatePassword function</h4>

	<script src="https://gist.github.com/pranavmayuram/46c77b8d1ce969fbcf61.js"></script>

	<p>Next, it checks to see that the user&#39;s email is verified. If you are unsure how this works, please refer to my past tutorial <a href="">here</a> to read how we did this. In summary, there is an attribute &#39;login.emailVerified&#39; which would change if the user did indeed verify their email. This is a boolean attribute, so we check to make sure that it evaluates as &#39;true&#39;, and if not we throw an error message to tell the user that their email is not yet verified.</p>

	<p>Finally, if all conditions above are met, we move on to the process of actually logging the user in. This includes adding a time to our user document array &#39;timeTracker.loginTimes&#39;, which we do using our <strong>User.addLoginTime</strong> function. This is in <strong>models/usermodel.js</strong> and also pasted below.</p>

	<h4>User.addLoginTime function</h4>

	<script src="https://gist.github.com/pranavmayuram/820b498990b2291c4ce1.js"></script>

	<p>This function uses a N1QL query to take the array of the user and essentially set it equal to the same array, but with the current time prepended to the &#39;timeTracker.loginTimes&#39; array. There is no way to currently just append something to an existing array in Couchbase, so this is a work-around to use until that functionality is added in the near future. The <strong>UPDATE</strong> statement ensures that the key we&#39;re searching for already exists, and that we are only updating an existing array. </p>

    <p> <strong>NOTE:</strong> Always make sure to use <strong>USE KEYS</strong> whenever you want to search a specific document ID. Using <strong>&#39;WHERE META(bucketname).id=var&#39;</strong> or any other <strong>WHERE</strong> statement is much slower, and will stop you from being able to read your own writes. In this example we use <strong>USE KEYS</strong> to make the query faster, and we also make sure to pass in all of our new variables in an array to the Node.js SDK to use for the query. This ensures that the query will be safer and avoid N1QL injection, similar to SQL injection.</p>

	<p>After this function executes successfully, we can go back to <strong>routes/routes.js</strong> to our API endpoint and look at the <strong>&#39;Session.create&#39;</strong> function that will be executed next. Here, we reach the beginning of creating a more secure application. Using <strong>&#39;Session.create&#39;</strong>, we pass in the user&#39;s ID, as we did to the last function. This can be found in <strong>models/sessionmodel.js</strong> or pasted below.</p>

	<h4>Session.create function</h4>

	<script src="https://gist.github.com/pranavmayuram/f6f07a6058114a98d44e.js"></script>

	<p>This function takes the user ID and generates a session document which has its own unique identifier, sessionID, and also the user ID of the user who&#39;s session it is, so that they can be identified. The &#39;userID&#39; field is useful for when we will want to create a &#39;My Profile&#39; page, or identify who may have made a certain post in our social network. We use a simple SDK insert request to add this document. Then we add an expiry to the document so that it expires one hour after it is added. After a user is logged in for over an hour, they will have to login again. This is to ensure safety and security, and one hour is a general standard for logins. Once this document is created, we will send a callback with the sessionModel, and then in our <strong>routes/routes.js</strong> file, we will send an object with the sessionID and expiry to the front-end. Here this sessionID will be stored in the browser&#39;s localStorage, so that it can be accessed whenever needed.</p>

	<p>After the sessionID is added to the localStorage, it will be sent along with any other data/parameters for any protected route. A protected route would be any API endpoint that has secure information that should only be accessed by users who are currently logged in. The way one typically sends this information along with the other data is in a request header. For this project I used Angular.js, so I put the sessionID from localStorage into the $http header for each API request, which can be seen in the <strong>&#39;$scope.getAllUsers&#39;</strong> function below.</p>

	<h4>$scope.getAllUsers front-end function</h4>

	<script src="https://gist.github.com/pranavmayuram/24e637e3e744b6ae7a76.js"></script>

	<p>I won&#39;t explain the way this function works, or the <strong>&#39;/api/advancedSearch&#39;</strong> endpoint it leads to, but if you look at the endpoint, and the function call for it, you will notice that it calls <strong>&#39;Session.auth&#39;</strong>, and then a callback in the function&#39;s arguments.</p>

	<h4>'/api/advancedSearch' API</h4>

	<script src="https://gist.github.com/pranavmayuram/6c30261d0b3a02e346b5.js"></script>

	<p>If you look over to the <strong>&#39;Session.auth&#39;</strong> function in <strong>models/sessionmodel.js</strong>, you will notice that it takes the sessionID from the request header, by doing a split operation on the $http header to parse it for the right information. The sessionID could be in the request body in certain instances (primarily picture upload), so that is handled in the function as well. Once the sessionID is taken from the header, or some other part of the request, then a N1QL query is performed to find the session document. Again, <strong>&#39;USE KEYS&#39;</strong> is implemented to keep speed in mind. In the case that no document is found with the sessionID we passed in, most probably meaning it has expired after one hour, then a response is sent with an object. This can be handled in many different ways on the front-end, and in my implementation, I simply send the user back to the login page <strong>if (&#39;!currentSession&#39;)</strong>.</p>

	<h4>Session.auth function</h4>

	<script src="https://gist.github.com/pranavmayuram/ee20714cfb36daf16385.js"></script>

	<p>This keeps the website secure since it is all handled on the back-end, and is not like a simple cookie, where the user is logged out if the cookie expires. In that case, the front-end javascript could easily be deleted or altered to gain access to site information. The reason I also pass the expiry from the session document to the front-end is to allow other developers to potentially add cookies on the front-end with expiries if they desire them.</p>

	<p>If the <strong>&#39;Session.auth&#39;</strong> function succeeds, and does find the correct document, it passes the document&#39;s corresponding user ID into the request object, and this can be accessed by any other function in the API endpoint so that it could receive user-specific information to get information for things like &#39;My Profile&#39;, or storing the user&#39;s ID in documents for the posts they make.</p>

	<p>That concludes our third tutorial on Touchbase, and I hope this was helpful for understanding one method of keeping an application secure. I am aware there are other alternatives like JSON web tokens, or OAuth 2.0, but in this case I chose a session-based approach and I hope it was helpful for any of you who choose a similar route of user authentication. If you have any questions, comments or feedback, please drop a comment below.</p>

</body>
</html>
